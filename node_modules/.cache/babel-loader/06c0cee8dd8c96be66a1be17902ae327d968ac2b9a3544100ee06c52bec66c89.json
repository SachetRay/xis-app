{"ast":null,"code":"// Helper function to determine data type and metadata\nfunction getMetadata(key, value, isLeaf) {\n  // Convert key to lowercase for easier matching\n  const keyLower = key.toLowerCase();\n\n  // Determine data owner based on field context\n  let dataOwner = 'System Admin';\n  if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataOwner = 'User Management Team';\n  } else if (keyLower.includes('payment') || keyLower.includes('billing')) {\n    dataOwner = 'Finance Team';\n  } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n    dataOwner = 'Analytics Team';\n  } else if (isLeaf) {\n    dataOwner = 'Data Team';\n  }\n\n  // Determine data source based on value type and context\n  let dataSource = 'System';\n  if (keyLower.includes('timestamp') || keyLower.includes('date')) {\n    dataSource = 'System Clock';\n  } else if (keyLower.includes('location') || keyLower.includes('address')) {\n    dataSource = 'Location Service';\n  } else if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataSource = 'User Profile';\n  } else if (typeof value === 'number' && keyLower.includes('id')) {\n    dataSource = 'ID Generator';\n  }\n\n  // Determine latency based on data type and update frequency\n  let latency = 'N/A';\n  if (isLeaf) {\n    if (keyLower.includes('timestamp') || keyLower.includes('status')) {\n      latency = 'Real-time';\n    } else if (keyLower.includes('cache') || keyLower.includes('temp')) {\n      latency = '5 minutes';\n    } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n      latency = '1 hour';\n    } else {\n      latency = 'On-demand';\n    }\n  }\n\n  // Create a more descriptive description\n  const formattedName = key.split(/(?=[A-Z])|_/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n  let description = `${formattedName} ${isLeaf ? 'field' : 'section'}`;\n  if (isLeaf) {\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      description += ' (Text)';\n    } else if (valueType === 'number') {\n      description += ' (Number)';\n    } else if (valueType === 'boolean') {\n      description += ' (Yes/No)';\n    } else if (value instanceof Date) {\n      description += ' (Date/Time)';\n    } else if (value === null) {\n      description += ' (Optional)';\n    }\n  }\n  return {\n    dataOwner,\n    dataSource,\n    latency,\n    description\n  };\n}\n\n// Simple and efficient tree transformation\nexport const transformToTree = obj => {\n  if (!obj || typeof obj !== 'object') return [];\n\n  // For arrays, map each item to a tree node\n  if (Array.isArray(obj)) {\n    return obj.map((item, index) => {\n      const isLeaf = typeof item !== 'object' || item === null;\n      const metadata = getMetadata(`Item ${index + 1}`, item, isLeaf);\n      return {\n        name: `Item ${index + 1}`,\n        type: isLeaf ? 'file' : 'folder',\n        value: isLeaf ? item : undefined,\n        children: !isLeaf ? transformToTree(item) : undefined,\n        ...metadata\n      };\n    });\n  }\n\n  // For objects, create tree nodes from key-value pairs\n  return Object.entries(obj).map(([key, value]) => {\n    const isLeaf = value === null || typeof value !== 'object';\n    const formattedName = key.split(/(?=[A-Z])|_/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n    const metadata = getMetadata(key, value, isLeaf);\n    return {\n      name: formattedName,\n      type: isLeaf ? 'file' : 'folder',\n      value: isLeaf ? value : undefined,\n      children: !isLeaf ? transformToTree(value) : undefined,\n      ...metadata\n    };\n  });\n};\nexport function searchInTree(nodes, query) {\n  const results = [];\n  const nodeArray = Array.isArray(nodes) ? nodes : [nodes];\n  const lowerQuery = query.toLowerCase().trim();\n  for (const node of nodeArray) {\n    // Check if the node's name or value matches the query (case-insensitive)\n    const nodeName = node.name.toLowerCase();\n    const nodeValue = node.value !== undefined ? String(node.value).toLowerCase() : '';\n    if (nodeName.includes(lowerQuery) || nodeValue.includes(lowerQuery)) {\n      results.push(node);\n    }\n\n    // Recursively search in children\n    if (node.children) {\n      results.push(...searchInTree(node.children, query));\n    }\n  }\n  return results;\n}\nexport function getPathToNode(targetNode, tree) {\n  const findPath = (nodes, target, currentPath) => {\n    for (const node of nodes) {\n      if (node.name === target.name && node.type === target.type) {\n        return [...currentPath, node.name];\n      }\n      if (node.type === 'folder' && node.children) {\n        const path = findPath(node.children, target, [...currentPath, node.name]);\n        if (path) return path;\n      }\n    }\n    return null;\n  };\n  for (const rootNode of tree) {\n    const path = findPath([rootNode], targetNode, []);\n    if (path) return path;\n  }\n  return [];\n}","map":{"version":3,"names":["getMetadata","key","value","isLeaf","keyLower","toLowerCase","dataOwner","includes","dataSource","latency","formattedName","split","map","word","charAt","toUpperCase","slice","join","description","valueType","Date","transformToTree","obj","Array","isArray","item","index","metadata","name","type","undefined","children","Object","entries","searchInTree","nodes","query","results","nodeArray","lowerQuery","trim","node","nodeName","nodeValue","String","push","getPathToNode","targetNode","tree","findPath","target","currentPath","path","rootNode"],"sources":["/Users/sachet/Desktop/XIS/src/utils/treeTransform.ts"],"sourcesContent":["export interface TreeNode {\n  name: string;\n  type: 'folder' | 'file';\n  value?: any;\n  children?: TreeNode[];\n  dataOwner?: string;\n  dataSource?: string;\n  latency?: string;\n  description?: string;\n}\n\n// Helper function to determine data type and metadata\nfunction getMetadata(key: string, value: any, isLeaf: boolean): Pick<TreeNode, 'dataOwner' | 'dataSource' | 'latency' | 'description'> {\n  // Convert key to lowercase for easier matching\n  const keyLower = key.toLowerCase();\n  \n  // Determine data owner based on field context\n  let dataOwner = 'System Admin';\n  if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataOwner = 'User Management Team';\n  } else if (keyLower.includes('payment') || keyLower.includes('billing')) {\n    dataOwner = 'Finance Team';\n  } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n    dataOwner = 'Analytics Team';\n  } else if (isLeaf) {\n    dataOwner = 'Data Team';\n  }\n\n  // Determine data source based on value type and context\n  let dataSource = 'System';\n  if (keyLower.includes('timestamp') || keyLower.includes('date')) {\n    dataSource = 'System Clock';\n  } else if (keyLower.includes('location') || keyLower.includes('address')) {\n    dataSource = 'Location Service';\n  } else if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataSource = 'User Profile';\n  } else if (typeof value === 'number' && keyLower.includes('id')) {\n    dataSource = 'ID Generator';\n  }\n\n  // Determine latency based on data type and update frequency\n  let latency = 'N/A';\n  if (isLeaf) {\n    if (keyLower.includes('timestamp') || keyLower.includes('status')) {\n      latency = 'Real-time';\n    } else if (keyLower.includes('cache') || keyLower.includes('temp')) {\n      latency = '5 minutes';\n    } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n      latency = '1 hour';\n    } else {\n      latency = 'On-demand';\n    }\n  }\n\n  // Create a more descriptive description\n  const formattedName = key\n    .split(/(?=[A-Z])|_/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n\n  let description = `${formattedName} ${isLeaf ? 'field' : 'section'}`;\n  if (isLeaf) {\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      description += ' (Text)';\n    } else if (valueType === 'number') {\n      description += ' (Number)';\n    } else if (valueType === 'boolean') {\n      description += ' (Yes/No)';\n    } else if (value instanceof Date) {\n      description += ' (Date/Time)';\n    } else if (value === null) {\n      description += ' (Optional)';\n    }\n  }\n\n  return {\n    dataOwner,\n    dataSource,\n    latency,\n    description\n  };\n}\n\n// Simple and efficient tree transformation\nexport const transformToTree = (obj: any): TreeNode[] => {\n  if (!obj || typeof obj !== 'object') return [];\n\n  // For arrays, map each item to a tree node\n  if (Array.isArray(obj)) {\n    return obj.map((item, index) => {\n      const isLeaf = typeof item !== 'object' || item === null;\n      const metadata = getMetadata(`Item ${index + 1}`, item, isLeaf);\n      \n      return {\n        name: `Item ${index + 1}`,\n        type: isLeaf ? 'file' : 'folder',\n        value: isLeaf ? item : undefined,\n        children: !isLeaf ? transformToTree(item) : undefined,\n        ...metadata\n      };\n    });\n  }\n\n  // For objects, create tree nodes from key-value pairs\n  return Object.entries(obj).map(([key, value]) => {\n    const isLeaf = value === null || typeof value !== 'object';\n    const formattedName = key\n      .split(/(?=[A-Z])|_/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n\n    const metadata = getMetadata(key, value, isLeaf);\n\n    return {\n      name: formattedName,\n      type: isLeaf ? 'file' : 'folder',\n      value: isLeaf ? value : undefined,\n      children: !isLeaf ? transformToTree(value) : undefined,\n      ...metadata\n    };\n  });\n};\n\nexport function searchInTree(nodes: TreeNode | TreeNode[], query: string): TreeNode[] {\n  const results: TreeNode[] = [];\n  const nodeArray = Array.isArray(nodes) ? nodes : [nodes];\n  const lowerQuery = query.toLowerCase().trim();\n  \n  for (const node of nodeArray) {\n    // Check if the node's name or value matches the query (case-insensitive)\n    const nodeName = node.name.toLowerCase();\n    const nodeValue = node.value !== undefined ? String(node.value).toLowerCase() : '';\n    \n    if (nodeName.includes(lowerQuery) || nodeValue.includes(lowerQuery)) {\n      results.push(node);\n    }\n    \n    // Recursively search in children\n    if (node.children) {\n      results.push(...searchInTree(node.children, query));\n    }\n  }\n  \n  return results;\n}\n\nexport function getPathToNode(targetNode: TreeNode, tree: TreeNode[]): string[] {\n  const findPath = (nodes: TreeNode[], target: TreeNode, currentPath: string[]): string[] | null => {\n    for (const node of nodes) {\n      if (node.name === target.name && node.type === target.type) {\n        return [...currentPath, node.name];\n      }\n      \n      if (node.type === 'folder' && node.children) {\n        const path = findPath(node.children, target, [...currentPath, node.name]);\n        if (path) return path;\n      }\n    }\n    return null;\n  };\n\n  for (const rootNode of tree) {\n    const path = findPath([rootNode], targetNode, []);\n    if (path) return path;\n  }\n  return [];\n} "],"mappings":"AAWA;AACA,SAASA,WAAWA,CAACC,GAAW,EAAEC,KAAU,EAAEC,MAAe,EAA0E;EACrI;EACA,MAAMC,QAAQ,GAAGH,GAAG,CAACI,WAAW,CAAC,CAAC;;EAElC;EACA,IAAIC,SAAS,GAAG,cAAc;EAC9B,IAAIF,QAAQ,CAACG,QAAQ,CAAC,MAAM,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;IAC7DD,SAAS,GAAG,sBAAsB;EACpC,CAAC,MAAM,IAAIF,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;IACvED,SAAS,GAAG,cAAc;EAC5B,CAAC,MAAM,IAAIF,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;IACzED,SAAS,GAAG,gBAAgB;EAC9B,CAAC,MAAM,IAAIH,MAAM,EAAE;IACjBG,SAAS,GAAG,WAAW;EACzB;;EAEA;EACA,IAAIE,UAAU,GAAG,QAAQ;EACzB,IAAIJ,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,MAAM,CAAC,EAAE;IAC/DC,UAAU,GAAG,cAAc;EAC7B,CAAC,MAAM,IAAIJ,QAAQ,CAACG,QAAQ,CAAC,UAAU,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;IACxEC,UAAU,GAAG,kBAAkB;EACjC,CAAC,MAAM,IAAIJ,QAAQ,CAACG,QAAQ,CAAC,MAAM,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;IACpEC,UAAU,GAAG,cAAc;EAC7B,CAAC,MAAM,IAAI,OAAON,KAAK,KAAK,QAAQ,IAAIE,QAAQ,CAACG,QAAQ,CAAC,IAAI,CAAC,EAAE;IAC/DC,UAAU,GAAG,cAAc;EAC7B;;EAEA;EACA,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIN,MAAM,EAAE;IACV,IAAIC,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,QAAQ,CAAC,EAAE;MACjEE,OAAO,GAAG,WAAW;IACvB,CAAC,MAAM,IAAIL,QAAQ,CAACG,QAAQ,CAAC,OAAO,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,MAAM,CAAC,EAAE;MAClEE,OAAO,GAAG,WAAW;IACvB,CAAC,MAAM,IAAIL,QAAQ,CAACG,QAAQ,CAAC,WAAW,CAAC,IAAIH,QAAQ,CAACG,QAAQ,CAAC,SAAS,CAAC,EAAE;MACzEE,OAAO,GAAG,QAAQ;IACpB,CAAC,MAAM;MACLA,OAAO,GAAG,WAAW;IACvB;EACF;;EAEA;EACA,MAAMC,aAAa,GAAGT,GAAG,CACtBU,KAAK,CAAC,aAAa,CAAC,CACpBC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAACX,WAAW,CAAC,CAAC,CAAC,CACvEY,IAAI,CAAC,GAAG,CAAC;EAEZ,IAAIC,WAAW,GAAG,GAAGR,aAAa,IAAIP,MAAM,GAAG,OAAO,GAAG,SAAS,EAAE;EACpE,IAAIA,MAAM,EAAE;IACV,MAAMgB,SAAS,GAAG,OAAOjB,KAAK;IAC9B,IAAIiB,SAAS,KAAK,QAAQ,EAAE;MAC1BD,WAAW,IAAI,SAAS;IAC1B,CAAC,MAAM,IAAIC,SAAS,KAAK,QAAQ,EAAE;MACjCD,WAAW,IAAI,WAAW;IAC5B,CAAC,MAAM,IAAIC,SAAS,KAAK,SAAS,EAAE;MAClCD,WAAW,IAAI,WAAW;IAC5B,CAAC,MAAM,IAAIhB,KAAK,YAAYkB,IAAI,EAAE;MAChCF,WAAW,IAAI,cAAc;IAC/B,CAAC,MAAM,IAAIhB,KAAK,KAAK,IAAI,EAAE;MACzBgB,WAAW,IAAI,aAAa;IAC9B;EACF;EAEA,OAAO;IACLZ,SAAS;IACTE,UAAU;IACVC,OAAO;IACPS;EACF,CAAC;AACH;;AAEA;AACA,OAAO,MAAMG,eAAe,GAAIC,GAAQ,IAAiB;EACvD,IAAI,CAACA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE,OAAO,EAAE;;EAE9C;EACA,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;IACtB,OAAOA,GAAG,CAACV,GAAG,CAAC,CAACa,IAAI,EAAEC,KAAK,KAAK;MAC9B,MAAMvB,MAAM,GAAG,OAAOsB,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI;MACxD,MAAME,QAAQ,GAAG3B,WAAW,CAAC,QAAQ0B,KAAK,GAAG,CAAC,EAAE,EAAED,IAAI,EAAEtB,MAAM,CAAC;MAE/D,OAAO;QACLyB,IAAI,EAAE,QAAQF,KAAK,GAAG,CAAC,EAAE;QACzBG,IAAI,EAAE1B,MAAM,GAAG,MAAM,GAAG,QAAQ;QAChCD,KAAK,EAAEC,MAAM,GAAGsB,IAAI,GAAGK,SAAS;QAChCC,QAAQ,EAAE,CAAC5B,MAAM,GAAGkB,eAAe,CAACI,IAAI,CAAC,GAAGK,SAAS;QACrD,GAAGH;MACL,CAAC;IACH,CAAC,CAAC;EACJ;;EAEA;EACA,OAAOK,MAAM,CAACC,OAAO,CAACX,GAAG,CAAC,CAACV,GAAG,CAAC,CAAC,CAACX,GAAG,EAAEC,KAAK,CAAC,KAAK;IAC/C,MAAMC,MAAM,GAAGD,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;IAC1D,MAAMQ,aAAa,GAAGT,GAAG,CACtBU,KAAK,CAAC,aAAa,CAAC,CACpBC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAACX,WAAW,CAAC,CAAC,CAAC,CACvEY,IAAI,CAAC,GAAG,CAAC;IAEZ,MAAMU,QAAQ,GAAG3B,WAAW,CAACC,GAAG,EAAEC,KAAK,EAAEC,MAAM,CAAC;IAEhD,OAAO;MACLyB,IAAI,EAAElB,aAAa;MACnBmB,IAAI,EAAE1B,MAAM,GAAG,MAAM,GAAG,QAAQ;MAChCD,KAAK,EAAEC,MAAM,GAAGD,KAAK,GAAG4B,SAAS;MACjCC,QAAQ,EAAE,CAAC5B,MAAM,GAAGkB,eAAe,CAACnB,KAAK,CAAC,GAAG4B,SAAS;MACtD,GAAGH;IACL,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;AAED,OAAO,SAASO,YAAYA,CAACC,KAA4B,EAAEC,KAAa,EAAc;EACpF,MAAMC,OAAmB,GAAG,EAAE;EAC9B,MAAMC,SAAS,GAAGf,KAAK,CAACC,OAAO,CAACW,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;EACxD,MAAMI,UAAU,GAAGH,KAAK,CAAC/B,WAAW,CAAC,CAAC,CAACmC,IAAI,CAAC,CAAC;EAE7C,KAAK,MAAMC,IAAI,IAAIH,SAAS,EAAE;IAC5B;IACA,MAAMI,QAAQ,GAAGD,IAAI,CAACb,IAAI,CAACvB,WAAW,CAAC,CAAC;IACxC,MAAMsC,SAAS,GAAGF,IAAI,CAACvC,KAAK,KAAK4B,SAAS,GAAGc,MAAM,CAACH,IAAI,CAACvC,KAAK,CAAC,CAACG,WAAW,CAAC,CAAC,GAAG,EAAE;IAElF,IAAIqC,QAAQ,CAACnC,QAAQ,CAACgC,UAAU,CAAC,IAAII,SAAS,CAACpC,QAAQ,CAACgC,UAAU,CAAC,EAAE;MACnEF,OAAO,CAACQ,IAAI,CAACJ,IAAI,CAAC;IACpB;;IAEA;IACA,IAAIA,IAAI,CAACV,QAAQ,EAAE;MACjBM,OAAO,CAACQ,IAAI,CAAC,GAAGX,YAAY,CAACO,IAAI,CAACV,QAAQ,EAAEK,KAAK,CAAC,CAAC;IACrD;EACF;EAEA,OAAOC,OAAO;AAChB;AAEA,OAAO,SAASS,aAAaA,CAACC,UAAoB,EAAEC,IAAgB,EAAY;EAC9E,MAAMC,QAAQ,GAAGA,CAACd,KAAiB,EAAEe,MAAgB,EAAEC,WAAqB,KAAsB;IAChG,KAAK,MAAMV,IAAI,IAAIN,KAAK,EAAE;MACxB,IAAIM,IAAI,CAACb,IAAI,KAAKsB,MAAM,CAACtB,IAAI,IAAIa,IAAI,CAACZ,IAAI,KAAKqB,MAAM,CAACrB,IAAI,EAAE;QAC1D,OAAO,CAAC,GAAGsB,WAAW,EAAEV,IAAI,CAACb,IAAI,CAAC;MACpC;MAEA,IAAIa,IAAI,CAACZ,IAAI,KAAK,QAAQ,IAAIY,IAAI,CAACV,QAAQ,EAAE;QAC3C,MAAMqB,IAAI,GAAGH,QAAQ,CAACR,IAAI,CAACV,QAAQ,EAAEmB,MAAM,EAAE,CAAC,GAAGC,WAAW,EAAEV,IAAI,CAACb,IAAI,CAAC,CAAC;QACzE,IAAIwB,IAAI,EAAE,OAAOA,IAAI;MACvB;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAED,KAAK,MAAMC,QAAQ,IAAIL,IAAI,EAAE;IAC3B,MAAMI,IAAI,GAAGH,QAAQ,CAAC,CAACI,QAAQ,CAAC,EAAEN,UAAU,EAAE,EAAE,CAAC;IACjD,IAAIK,IAAI,EAAE,OAAOA,IAAI;EACvB;EACA,OAAO,EAAE;AACX","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}