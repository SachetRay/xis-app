{"ast":null,"code":"// Helper function to determine data type and metadata\nfunction getMetadata(key,value,isLeaf){// Convert key to lowercase for easier matching\nconst keyLower=key.toLowerCase();// Determine data owner based on field context\nlet dataOwner='System Admin';if(keyLower.includes('user')||keyLower.includes('profile')){dataOwner='User Management Team';}else if(keyLower.includes('payment')||keyLower.includes('billing')){dataOwner='Finance Team';}else if(keyLower.includes('analytics')||keyLower.includes('metrics')){dataOwner='Analytics Team';}else if(isLeaf){dataOwner='Data Team';}// Determine data source based on value type and context\nlet dataSource='System';if(keyLower.includes('timestamp')||keyLower.includes('date')){dataSource='System Clock';}else if(keyLower.includes('location')||keyLower.includes('address')){dataSource='Location Service';}else if(keyLower.includes('user')||keyLower.includes('profile')){dataSource='User Profile';}else if(typeof value==='number'&&keyLower.includes('id')){dataSource='ID Generator';}// Determine latency based on data type and update frequency\nlet latency='N/A';if(isLeaf){if(keyLower.includes('timestamp')||keyLower.includes('status')){latency='Real-time';}else if(keyLower.includes('cache')||keyLower.includes('temp')){latency='5 minutes';}else if(keyLower.includes('analytics')||keyLower.includes('metrics')){latency='1 hour';}else{latency='On-demand';}}// Create a more descriptive description\nconst formattedName=key.split(/(?=[A-Z])|_/).map(word=>word.charAt(0).toUpperCase()+word.slice(1).toLowerCase()).join(' ');let description=`${formattedName} ${isLeaf?'field':'section'}`;if(isLeaf){const valueType=typeof value;if(valueType==='string'){description+=' (Text)';}else if(valueType==='number'){description+=' (Number)';}else if(valueType==='boolean'){description+=' (Yes/No)';}else if(value instanceof Date){description+=' (Date/Time)';}else if(value===null){description+=' (Optional)';}}return{dataOwner,dataSource,latency,description};}// Simple and efficient tree transformation\nexport const transformToTree=obj=>{if(!obj||typeof obj!=='object')return[];// For arrays, map each item to a tree node\nif(Array.isArray(obj)){return obj.map((item,index)=>{const isLeaf=typeof item!=='object'||item===null;const metadata=getMetadata(`Item ${index+1}`,item,isLeaf);return{name:`Item ${index+1}`,type:isLeaf?'file':'folder',value:isLeaf?item:undefined,children:!isLeaf?transformToTree(item):undefined,...metadata};});}// For objects, create tree nodes from key-value pairs\nreturn Object.entries(obj).map(_ref=>{let[key,value]=_ref;const isLeaf=value===null||typeof value!=='object';const formattedName=key.split(/(?=[A-Z])|_/).map(word=>word.charAt(0).toUpperCase()+word.slice(1).toLowerCase()).join(' ');const metadata=getMetadata(key,value,isLeaf);return{name:formattedName,type:isLeaf?'file':'folder',value:isLeaf?value:undefined,children:!isLeaf?transformToTree(value):undefined,...metadata};});};export function searchInTree(nodes,query){const results=[];const nodeArray=Array.isArray(nodes)?nodes:[nodes];const lowerQuery=query.toLowerCase().trim();for(const node of nodeArray){// Check if the node's name or value matches the query (case-insensitive)\nconst nodeName=node.name.toLowerCase();const nodeValue=node.value!==undefined?String(node.value).toLowerCase():'';if(nodeName.includes(lowerQuery)||nodeValue.includes(lowerQuery)){results.push(node);}// Recursively search in children\nif(node.children){results.push(...searchInTree(node.children,query));}}return results;}export function getPathToNode(targetNode,tree){const findPath=(nodes,target,currentPath)=>{for(const node of nodes){if(node.name===target.name&&node.type===target.type){return[...currentPath,node.name];}if(node.type==='folder'&&node.children){const path=findPath(node.children,target,[...currentPath,node.name]);if(path)return path;}}return null;};for(const rootNode of tree){const path=findPath([rootNode],targetNode,[]);if(path)return path;}return[];}","map":{"version":3,"names":["getMetadata","key","value","isLeaf","keyLower","toLowerCase","dataOwner","includes","dataSource","latency","formattedName","split","map","word","charAt","toUpperCase","slice","join","description","valueType","Date","transformToTree","obj","Array","isArray","item","index","metadata","name","type","undefined","children","Object","entries","_ref","searchInTree","nodes","query","results","nodeArray","lowerQuery","trim","node","nodeName","nodeValue","String","push","getPathToNode","targetNode","tree","findPath","target","currentPath","path","rootNode"],"sources":["/Users/sachet/Desktop/XIS/src/utils/treeTransform.ts"],"sourcesContent":["export interface TreeNode {\n  name: string;\n  type: 'folder' | 'file';\n  value?: any;\n  children?: TreeNode[];\n  dataOwner?: string;\n  dataSource?: string;\n  latency?: string;\n  description?: string;\n}\n\n// Helper function to determine data type and metadata\nfunction getMetadata(key: string, value: any, isLeaf: boolean): Pick<TreeNode, 'dataOwner' | 'dataSource' | 'latency' | 'description'> {\n  // Convert key to lowercase for easier matching\n  const keyLower = key.toLowerCase();\n  \n  // Determine data owner based on field context\n  let dataOwner = 'System Admin';\n  if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataOwner = 'User Management Team';\n  } else if (keyLower.includes('payment') || keyLower.includes('billing')) {\n    dataOwner = 'Finance Team';\n  } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n    dataOwner = 'Analytics Team';\n  } else if (isLeaf) {\n    dataOwner = 'Data Team';\n  }\n\n  // Determine data source based on value type and context\n  let dataSource = 'System';\n  if (keyLower.includes('timestamp') || keyLower.includes('date')) {\n    dataSource = 'System Clock';\n  } else if (keyLower.includes('location') || keyLower.includes('address')) {\n    dataSource = 'Location Service';\n  } else if (keyLower.includes('user') || keyLower.includes('profile')) {\n    dataSource = 'User Profile';\n  } else if (typeof value === 'number' && keyLower.includes('id')) {\n    dataSource = 'ID Generator';\n  }\n\n  // Determine latency based on data type and update frequency\n  let latency = 'N/A';\n  if (isLeaf) {\n    if (keyLower.includes('timestamp') || keyLower.includes('status')) {\n      latency = 'Real-time';\n    } else if (keyLower.includes('cache') || keyLower.includes('temp')) {\n      latency = '5 minutes';\n    } else if (keyLower.includes('analytics') || keyLower.includes('metrics')) {\n      latency = '1 hour';\n    } else {\n      latency = 'On-demand';\n    }\n  }\n\n  // Create a more descriptive description\n  const formattedName = key\n    .split(/(?=[A-Z])|_/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(' ');\n\n  let description = `${formattedName} ${isLeaf ? 'field' : 'section'}`;\n  if (isLeaf) {\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      description += ' (Text)';\n    } else if (valueType === 'number') {\n      description += ' (Number)';\n    } else if (valueType === 'boolean') {\n      description += ' (Yes/No)';\n    } else if (value instanceof Date) {\n      description += ' (Date/Time)';\n    } else if (value === null) {\n      description += ' (Optional)';\n    }\n  }\n\n  return {\n    dataOwner,\n    dataSource,\n    latency,\n    description\n  };\n}\n\n// Simple and efficient tree transformation\nexport const transformToTree = (obj: any): TreeNode[] => {\n  if (!obj || typeof obj !== 'object') return [];\n\n  // For arrays, map each item to a tree node\n  if (Array.isArray(obj)) {\n    return obj.map((item, index) => {\n      const isLeaf = typeof item !== 'object' || item === null;\n      const metadata = getMetadata(`Item ${index + 1}`, item, isLeaf);\n      \n      return {\n        name: `Item ${index + 1}`,\n        type: isLeaf ? 'file' : 'folder',\n        value: isLeaf ? item : undefined,\n        children: !isLeaf ? transformToTree(item) : undefined,\n        ...metadata\n      };\n    });\n  }\n\n  // For objects, create tree nodes from key-value pairs\n  return Object.entries(obj).map(([key, value]) => {\n    const isLeaf = value === null || typeof value !== 'object';\n    const formattedName = key\n      .split(/(?=[A-Z])|_/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n\n    const metadata = getMetadata(key, value, isLeaf);\n\n    return {\n      name: formattedName,\n      type: isLeaf ? 'file' : 'folder',\n      value: isLeaf ? value : undefined,\n      children: !isLeaf ? transformToTree(value) : undefined,\n      ...metadata\n    };\n  });\n};\n\nexport function searchInTree(nodes: TreeNode | TreeNode[], query: string): TreeNode[] {\n  const results: TreeNode[] = [];\n  const nodeArray = Array.isArray(nodes) ? nodes : [nodes];\n  const lowerQuery = query.toLowerCase().trim();\n  \n  for (const node of nodeArray) {\n    // Check if the node's name or value matches the query (case-insensitive)\n    const nodeName = node.name.toLowerCase();\n    const nodeValue = node.value !== undefined ? String(node.value).toLowerCase() : '';\n    \n    if (nodeName.includes(lowerQuery) || nodeValue.includes(lowerQuery)) {\n      results.push(node);\n    }\n    \n    // Recursively search in children\n    if (node.children) {\n      results.push(...searchInTree(node.children, query));\n    }\n  }\n  \n  return results;\n}\n\nexport function getPathToNode(targetNode: TreeNode, tree: TreeNode[]): string[] {\n  const findPath = (nodes: TreeNode[], target: TreeNode, currentPath: string[]): string[] | null => {\n    for (const node of nodes) {\n      if (node.name === target.name && node.type === target.type) {\n        return [...currentPath, node.name];\n      }\n      \n      if (node.type === 'folder' && node.children) {\n        const path = findPath(node.children, target, [...currentPath, node.name]);\n        if (path) return path;\n      }\n    }\n    return null;\n  };\n\n  for (const rootNode of tree) {\n    const path = findPath([rootNode], targetNode, []);\n    if (path) return path;\n  }\n  return [];\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}